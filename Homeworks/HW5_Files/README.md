# HW 5. Files

Современная биоинформатика почти на 100% завязана на работу с файлами. Этим мы с вами и займемся.

## Основное задание

Состоит из 3-х пунктов: 0, A и B. Все примеры файлов приложены в папке `example_data`.

❗️ Обратите внимение на пункт 0. ❗️

#### 0. Cтруктура репозитория
В вашем репозитории из ДЗ 4 (ваши биоинформатические утилиты) сейчас есть 2 ветки: main и *вторая*. 

```
  (main)
-x
  \         (вторая ветка)
   x-x-x-x-x
```




Из *второй* ветки в main у вас уже направлен pull-request (ваше ДЗ 4). 

```
  (main)
-x..........
  \        ↑ (HW4)
   x-x-x-x-x(вторая ветка)
```


Перейдите на ***вторую*** ветку и начните от её последнего коммита ***новую третью ветку***. По выполнению задания сделайте pull-request из ***третьей*** ветки в во ***вторую***. Должно быть так:

```
  (main)
-x..........
  \        ↑ (HW4)
   x-x-x-x-x..........(вторая)
            \        ↑ (HW5)
             x-x-x-x-x(третья)
```


- ❗️ Никакие PRы закрывать/мерджить не надо
- ❗️ Должен появиться PR (3) -> (2). 

#### A. **Добработка FASTQ-модуля**

1) У нас есть модуль для работы с FASTQ-данными в виде словарей, но в реальной же жизни они приходят к нам в виде FASTQ-файлов. Исправьте главную функцию так, чтобы *вместо* словаря `seqs` она принимала аргумент `input_fastq`, а также добавьте аргумент `output_fastq`. 

2) Реализуйте функцию для чтения чтения файла по заданному пути и переводу его в знакомый вам словарь. Все остальные функции по-идее уже умеют работать с этим словарем.

3) Реализуйте функцию для записи файла. Она принимает из главной фунции сиквенсы на запись и `output_fastq`, и сохраняет отфильтрованные данные ***в папку*** `filtered` (ее может и не быть) по имени `output_fastq`. 

Пусть функции для чтения и записи лежат не в главном скрипте, а в модуле с остальными функциями для фильтрации.

Постарайтесь сделать так, чтобы пользователь не мог случайно стереть/перезаписать имеющиеся у него данные. 

Сможете ли вы сделать так, чтобы вся фильтрация происходила "на лету" - читаем сиквенс, сразу его проверяем и сразу записываем при необходимости? То есть чтобы программа работала с заботой об оперативке и не хранила в памяти больше одного сиквенса за раз.

Про fastq-файлы можно посмотреть, например, [здесь](https://stepik.org/lesson/32398/step/1?unit=12379).


#### B. **Чтение биоинформатических файлов.**
    
Создайте в корне вашего репозитория био-утилит новый скрипт - `bio_files_processor.py`. Реализуйте в нем любые ДВЕ из трех предложенных функций (на ваш выбор). Функции приведены по возрастанию хардовости. 
      
1) Функция `convert_multiline_fasta_to_oneline`. 

<img src="image.png" width="80"/>

   Принимает на вход 2 аргумента (`input_fasta` и `output_fasta`). Читает поданный на вход *fasta*-файл, в котором последовательность (ДНК/РНК/белка/ … ) может быть разбита на несколько строк, после чего сохраняет в новый fasta-файл в котором каждая последовательность умещается в одну строку. Попробуйте сделать аргумент `output_fasta` не обязтальным.

2) Функция `parse_blast_output`.

<img src="image-1.png" width="80"/>

   > В одном  из проектов по практикуму вам будет необходимо проанализировать механизм возникновения антибиотикоустойчивости у патогенной кишечной палочки. Один из способов анализа - это достать из gbk аннотации гены, фланкирующие гены антибиотикоустойчивости, и после - забластить их. Особенно удобно тут то, что BLAST может принимать множество последовательностей для поиска за раз.
   >
   > Допустим, вы это сделали. Теперь вы хотите по каждой последовательности вытащить название наилучшего совпадения с базой и сохранить все результаты в одном месте. Для отладки предлагается забластить файл полученный в следующем задании и скачать результаты в виде txt, однако вы можете использовать и уже готовый файл `example_blast_results.txt`.

   Принимает на вход 2 аргумента (`input_file`, `output_file`). Программа читает заданный txt файл, для каждого запроса QUERY (абзац `Sequences producing significant alignments:`) выбрать по первой строке из столбца `Description`. Набор полученных белков сохранить в новый файл одним столбцом отсортированным по алфавиту.


3) Функция `select_genes_from_gbk_to_fasta`. 

<img src="image-2.png" width="80"/>
   
   > Всё замечательно, но как достать из gbk нужные гены? Давайте это сделаем. Допустим у вас имеется аннотация генома *E. coli* в которой есть несколько генов интереса. Теперь вы хотите выделить какое-то количество генов до и после каждого из гена интереса и сохранить их белковую последовательность (translation) в fasta-файл. Такой fasta-файл можно будет прямо в явном виде отправить на вход BLAST чтобы анализировать интересующие вас механизмы.

   Принимает на вход следующие аргументы:
   + `input_gbk` - путь до входного GBK файла.
   + `genes` - гены интереса, рядом с которыми ищутся соседи. Имейте ввиду, что в gbk название гена может включать дополнительные символы ([подсказка](https://stackoverflow.com/questions/4843158/how-to-check-if-a-string-is-a-substring-of-items-in-a-list-of-strings))
   + `n_before`, `n_after` - количество генов до и послe (>=1). Дефолтные значения - `1`. 
   + `output_fasta` - название выходного файла. 

   </br>
   


### Доп. моменты:
- Появилось что-то новое? Не забудьте обновить ридми:)
- Можно использовать только стандартную библиотеку. При чтении подобных биологических файлов в будущем можно будет найти соответствующие библиотеки (например biopython), однако сейчас лучше парсить их в список списков или список словарей - так вы лучше разберетесь с “голым” чтением файлов, что будет полезным если соответствующие библиотеки будут отсутсвовать.
- Функция `convert_multiline_fasta_to_oneline` чуть более алгоритмическая задачка, советую сперва продумать как правильно читать файл, мб нарисуйте это на листочке. Функция `parse_blast_output` чуть более про доставание нужной информации. Тут мб советую помедитировать над входным файлом. Функция `select_genes_from_gbk_to_fasta` объединяет в себя и то и то.
- Автотестов в этом ДЗ нет, но обязательно сами прогоните линтеры на стиль кода.


### Форма сдачи

Прикрепите ссылку на свой pull-request Google Class.


### Pазбалловка

- Доработка FASTQ: **20 баллов**
- Каждая из двух функций части B: **по 35 баллов**
- Обновление README: **10 баллов**

- За реализацию третьей функции из части B (итого 3/3): **+10 доп. баллов**
- В FASTQ-модуле фильтрация делается "на лету": **+5 доп. баллов**

Обратите внимание, что стиль кода и стройности логики кода - также влияют на оценку. 



### **Предполагаемый учебный результат**

Это задание позволит разобраться с тем как доставать нужную информацию из не всегда очень удачных по структуре биологических файлов (коих несчетное множество и не для всех из них имеются специализированные библиотеки). Дополнительный бонус - написанные скрипты можно будет непосредственно использовать в проектах по практикуму!

Удачи! ✨✨